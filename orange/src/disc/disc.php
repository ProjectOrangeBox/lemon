<?php

declare(strict_types=1);

namespace dmyers\orange\disc;

use dmyers\orange\disc\File;
use dmyers\orange\disc\Load;
use dmyers\orange\disc\Save;
use dmyers\orange\disc\Directory;
use dmyers\orange\disc\exceptions\DiscException;

/**
 * File System Functions
 *
 * File System Abstraction which automatically
 * works in a given root path
 *
 * Can be added with composer by adding a composer.json file with:
 *
 *"autoload": {
 *   "files": ["src/Disc.php"]
 * }
 */
class Disc
{
	protected static $rootPath = '';
	protected static $rootLength = 0;
	protected static $autoGenerateDirectories = true;

	/**
	 * set application root directory
	 *
	 * @param string $path [path to root directory]
	 * @return void
	 */
	public static function root(string $path, bool $chdir = true): void
	{
		/* Returns canonicalized absolute pathname */
		$realpath = \realpath($path);

		if (!$realpath) {
			throw new discException('"' . $path . '" is not a valid directory.');
		}

		/* save it */
		self::$rootPath = $realpath;

		/* calculate it once here */
		self::$rootLength = \strlen($realpath);

		/* change directory to it */
		if ($chdir) {
			\chdir(self::$rootPath);
		}

		/* default true they can change it to false if they need to with the autoGenerateDirectories function */
		self::autoGenerateDirectories(true);
	}

	/**
	 * Method getRoot
	 *
	 * @return string
	 */
	public static function getRoot(): string
	{
		return self::$rootPath;
	}

	/**
	 * Method autoGenerateDirectories
	 *
	 * @param bool $bool [explicite description]
	 *
	 * @return void
	 */
	public static function autoGenerateDirectories(bool $bool = true): void
	{
		self::$autoGenerateDirectories = $bool;
	}

	/**
	 * Format a given path so it's based on the applications root folder __ROOT__.
	 *
	 * Either add or remove __ROOT__ from path
	 *
	 * @param string $path [path to file/directory]
	 * @param bool $remove false [remove the root path]
	 *
	 * @return string
	 */
	public static function resolve(string $path, bool $remove = false): string
	{
		if (empty(self::$rootPath)) {
			throw new discException(__METHOD__ . ' root path is not defined. Use disc::root(...).');
		}

		/* strip it if root path is already present */
		$path = (\substr($path, 0, self::$rootLength) == self::$rootPath) ? \substr($path, self::$rootLength) : $path;

		/* now resolve - stripped or added? */
		return ($remove) ? \rtrim($path, DIRECTORY_SEPARATOR) : self::$rootPath . DIRECTORY_SEPARATOR . \trim($path, DIRECTORY_SEPARATOR);
	}

	/**
	 * Method stripRootPath
	 *
	 * @param string|array $files [array of file pathes or single file path]
	 * @param bool $remove [add or remove path to passed]
	 *
	 * @return string|array
	 */
	public static function stripRootPath($files, bool $remove = true)
	{
		/* strip the root path */
		if (is_array($files)) {
			foreach ($files as $index => $file) {
				$files[$index] = self::resolve($file, $remove);
			}
		} else {
			$files = self::resolve($files, $remove);
		}

		return $files;
	}

	/**
	 * Method fileExists
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public static function exists(string $path): bool
	{
		return \file_exists(self::resolve($path));
	}

	/**
	 * Method required
	 *
	 * Check to see if path or file is present
	 * This is used by other functions which require the file or path to be present
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public static function required(string $path): bool
	{
		$success = \file_exists(self::resolve($path));

		if (!$success) {
			throw new discException('No such file or directory. ' . $path);
		}

		return $success;
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function require(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return require self::resolve($requiredPath);
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function requireOnce(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return require_once self::resolve($requiredPath);
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function include(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return include self::resolve($requiredPath);
	}

	/**
	 * Method includeOnce
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function includeOnce(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return include_once self::resolve($requiredPath);
	}

	public static function directory(string $path): Directory
	{
		return new Directory(self::resolve($path));
	}

	public static function open(string $path, string $mode = 'r') /* resource|false */
	{
		if (is_dir(self::resolve($path))) {
			throw new discException('Cannot Open Directory');
		}

		if (in_array($mode, ['r', 'r+'])) {
			self::required($path);
		} else {
			self::autoGenMissingDirectory($path);
		}

		return new File(self::resolve($path), $mode);
	}

	public static function append(string $path, string $mode = 'a')  /* resource|false */
	{
		return self::open($path, $mode);
	}

	public static function create(string $path, string $mode = 'w') /* resource|false */
	{
		return self::open($path, $mode);
	}

	public static function file(string $path)
	{
		return self::open($path, 'r');
	}

	public static function makeDirectory(string $path, int $mode = 0777, bool $recursive = true): bool
	{
		$path = self::resolve($path);

		if (!\file_exists($path)) {
			$umask = \umask(0);
			$bool = \mkdir($path, $mode, $recursive);
			\umask($umask);
		} else {
			$bool = true;
		}

		return $bool;
	}

	/**
	 * Method bytesToString
	 *
	 * @param int $bytes [explicite description]
	 *
	 * @return string
	 */
	public static function formatSize(int $bytes): string
	{
		$i = floor(log($bytes, 1024));

		return round($bytes / pow(1024, $i), [0, 0, 2, 2, 3][$i]) . ['B', 'kB', 'MB', 'GB', 'TB'][$i];
	}

	/**
	 * Method permissionsFormatted
	 *
	 * @param int $mode [explicite description]
	 * @param int $option [explicite description]
	 *
	 * @return string
	 */
	public static function formatPermissions(int $mode, int $option = 3): string
	{
		$info = '';

		if (1 & $option) {
			switch ($mode & 0xF000) {
					// socket
				case 0xC000:
					$info = 's';
					break;
					// symbolic link
				case 0xA000:
					$info = 'l';
					break;
					// regular
				case 0x8000:
					$info = 'r';
					break;
					// block special
				case 0x6000:
					$info = 'b';
					break;
					// directory
				case 0x4000:
					$info = 'd';
					break;
					// character special
				case 0x2000:
					$info = 'c';
					break;
					// FIFO pipe
				case 0x1000:
					$info = 'p';
					break;
					// unknown
				default:
					$info = 'u';
			}
		}

		if (2 & $option) {
			// Owner
			$info .= (($mode & 0x0100) ? 'r' : '-');
			$info .= (($mode & 0x0080) ? 'w' : '-');
			$info .= (($mode & 0x0040) ? (($mode & 0x0800) ? 's' : 'x') : (($mode & 0x0800) ? 'S' : '-'));

			// Group
			$info .= (($mode & 0x0020) ? 'r' : '-');
			$info .= (($mode & 0x0010) ? 'w' : '-');
			$info .= (($mode & 0x0008) ? (($mode & 0x0400) ? 's' : 'x') : (($mode & 0x0400) ? 'S' : '-'));

			// World
			$info .= (($mode & 0x0004) ? 'r' : '-');
			$info .= (($mode & 0x0002) ? 'w' : '-');
			$info .= (($mode & 0x0001) ? (($mode & 0x0200) ? 't' : 'x') : (($mode & 0x0200) ? 'T' : '-'));
		}

		return $info;
	}

	public static function autoGenMissingDirectory(string $requiredPath)
	{
		if (self::$autoGenerateDirectories) {
			self::makeDirectory(dirname($requiredPath));
		}
	}

	public static function rename(File $fileObj, string $newname): File
	{
		self::autoGenMissingDirectory($newname);

		$oldname = $fileObj->getRealPath();

		$fileObj = null; /* close */

		\rename($oldname, self::resolve($newname));

		return self::file($newname);
	}

	public static function save(string $path, $input = null, ?int $chmod = null, $arg1 = null): Save
	{
		return new Save($path, $input, $chmod, $arg1);
	}

	public static function load(string $path, bool $processFile = true, $arg1 = null, $arg2 = null) /* mixed */
	{
		$loader = new Load($path, $processFile, $arg1, $arg2);

		return (!$processFile) ? $loader : $loader->loaded();
	}

	/**
	 * New (but used automatically by file_put_contents when no flags are used)
	 *
	 * atomicFilePutContents - atomic file_put_contents
	 *
	 * @param string $path
	 * @param mixed $content
	 * @return int returns the number of bytes that were written to the file.
	 */
	public static function atomicSaveContent(string $path, $content): int
	{
		/* create absolute path */
		$path = Disc::resolve($path);

		Disc::autoGenMissingDirectory($path);

		/* get the path where you want to save this file so we can put our file in the same directory */
		$directory = \dirname($path);

		/* is this directory writeable */
		if (!is_writable($directory)) {
			throw new discException($directory . ' is not writable.');
		}

		/* create a temporary file with unique file name and prefix */
		$temporaryFile = \tempnam($directory, 'afpc_');

		/* did we get a temporary filename */
		if ($temporaryFile === false) {
			throw new discException('Could not create temporary file ' . $temporaryFile . '.');
		}

		/* write to the temporary file */
		$bytes = \file_put_contents($temporaryFile, $content, LOCK_EX);

		/* did we write anything? */
		if ($bytes === false) {
			throw new discException('No bytes written by file_put_contents');
		}

		/* move it into place - this is the atomic function */
		if (\rename($temporaryFile, $path) === false) {
			throw new discException('Could not rename temporary file ' . $temporaryFile . ' ' . $path . '.');
		}

		/* return the number of bytes written */
		return $bytes;
	}

	/**
	 * Method removePhpFileFromOpcache
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public static function removePhpFileFromOpcache(string $path): bool
	{
		return (\function_exists('opcache_invalidate')) ? \opcache_invalidate(Disc::resolve($path), true) : true;
	}
} /* end class */
