<?php

declare(strict_types=1);

namespace dmyers\orange;

use dmyers\orange\File;
use dmyers\orange\exceptions\discSystemException;

/**
 * File System Functions
 *
 * File System Abstraction which automatically
 * works in a given root path
 *
 * Can be added with composer by adding a composer.json file with:
 *
 *"autoload": {
 *   "files": ["src/Disc.php"]
 * }
 */
class Disc
{
	const JSONFLAGS = JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP | JSON_UNESCAPED_UNICODE;

	protected static $rootPath = '';
	protected static $rootLength = 0;
	protected static $autoGenerateDirectories = true;

	/**
	 * set application root directory
	 *
	 * @param string $path [path to root directory]
	 * @return void
	 */
	public static function root(string $path, bool $chdir = true): void
	{
		/* Returns canonicalized absolute pathname */
		$realpath = \realpath($path);

		if (!$realpath) {
			throw new discSystemException('"' . $path . '" is not a valid directory.');
		}

		/* save it */
		self::$rootPath = $realpath;

		/* calculate it once here */
		self::$rootLength = \strlen($realpath);

		/* change directory to it */
		if ($chdir) {
			\chdir(self::$rootPath);
		}

		/* default true they can change it to false if they need to with the autoGenerateDirectories function */
		self::autoGenerateDirectories(true);
	}

	/**
	 * Method getRoot
	 *
	 * @return string
	 */
	public static function getRoot(): string
	{
		return self::$rootPath;
	}

	/**
	 * Method autoGenerateDirectories
	 *
	 * @param bool $bool [explicite description]
	 *
	 * @return void
	 */
	public static function autoGenerateDirectories(bool $bool = true): void
	{
		self::$autoGenerateDirectories = $bool;
	}

	/**
	 * Format a given path so it's based on the applications root folder __ROOT__.
	 *
	 * Either add or remove __ROOT__ from path
	 *
	 * @param string $path [path to file/directory]
	 * @param bool $remove false [remove the root path]
	 *
	 * @return string
	 */
	public static function resolve(string $path, bool $remove = false): string
	{
		if (empty(self::$rootPath)) {
			throw new discSystemException(__METHOD__ . ' root path is not defined. Use disc::root(...).');
		}

		/* strip it if root path is already present */
		$path = (\substr($path, 0, self::$rootLength) == self::$rootPath) ? \substr($path, self::$rootLength) : $path;

		/* now resolve - stripped or added? */
		return ($remove) ? \rtrim($path, DIRECTORY_SEPARATOR) : self::$rootPath . DIRECTORY_SEPARATOR . \trim($path, DIRECTORY_SEPARATOR);
	}

	/**
	 * Method stripRootPath
	 *
	 * @param string|array $files [array of file pathes or single file path]
	 * @param bool $remove [add or remove path to passed]
	 *
	 * @return string|array
	 */
	public static function stripRootPath($files, bool $remove = true)
	{
		/* strip the root path */
		if (is_array($files)) {
			foreach ($files as $index => $file) {
				$files[$index] = self::resolve($file, $remove);
			}
		} else {
			$files = self::resolve($files, $remove);
		}

		return $files;
	}

	/**
	 * Method fileExists
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public function exists(string $path): bool
	{
		return \file_exists(Disc::resolve($path));
	}

	/**
	 * Method required
	 *
	 * Check to see if path or file is present
	 * This is used by other functions which require the file or path to be present
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public static function required(string $path): bool
	{
		$success = \file_exists(self::resolve($path));

		if (!$success) {
			throw new discSystemException('No such file or directory. ' . $path);
		}

		return $success;
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function require(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return require self::resolve($requiredPath);
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function requireOnce(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return require_once self::resolve($requiredPath);
	}

	/**
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function include(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return include self::resolve($requiredPath);
	}

	/**
	 * Method includeOnce
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return mixed
	 */
	public static function includeOnce(string $requiredPath) /* mixed|bool */
	{
		self::required($requiredPath);

		return include_once self::resolve($requiredPath);
	}

	/**
	 * List all pattern matched files in folder
	 *
	 * @param string $pattern
	 * @param int $flags
	 *
	 * @return array
	 */
	public static function list(string $requiredPath, string $pattern = '*', int $flags = 0): array
	{
		self::required($requiredPath);

		return self::stripRootPath(\glob(self::resolve($requiredPath . '/' . $pattern), $flags));
	}

	/**
	 * recursive list all pattern matched files in folder
	 *
	 * @param string $pattern
	 * @param int $flags
	 *
	 * @return array
	 */
	public static function listAll(string $requiredPath, string $pattern = '*', int $flags = 0): array
	{
		self::required($requiredPath);

		return self::stripRootPath(self::listRecursive(self::resolve($requiredPath . '/' . $pattern), $flags));
	}


	public static function open(string $path, string $mode = 'r') /* resource|false */
	{
		if (is_dir(self::resolve($path))) {
			throw new discSystemException('Cannot Open Directory');
		}

		if (in_array($mode, ['r', 'r+'])) {
			self::required($path);
		} else {
			self::autoGenMissingDirectory($path);
		}

		return new File(self::resolve($path), $mode);
	}

	public static function append(string $path, string $mode = 'a')  /* resource|false */
	{
		return self::open($path, $mode);
	}

	public static function create(string $path, string $mode = 'w') /* resource|false */
	{
		return self::open($path, $mode);
	}

	public static function file(string $path)
	{
		return self::open($path, 'r');
	}

	public static function makeDirectory(string $path, int $mode = 0777, bool $recursive = true): bool
	{
		$path = self::resolve($path);

		if (!\file_exists($path)) {
			$umask = \umask(0);
			$bool = \mkdir($path, $mode, $recursive);
			\umask($umask);
		} else {
			$bool = true;
		}

		return $bool;
	}

	/**
	 * Method rmdirRecursive
	 *
	 * @param string $path [explicite description]
	 *
	 * @return bool
	 */
	public static function remove(string $path): bool
	{
		self::required($path);

		$path = self::resolve($path);

		if (!is_dir($path)) {
			throw new discSystemException('Directory Not Found');
		}

		$files = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::CHILD_FIRST);

		foreach ($files as $fileinfo) {
			if ($fileinfo->isDir()) {
				self::remove($fileinfo->getRealPath());
			} else {
				\unlink($fileinfo->getRealPath());
			}
		}

		return \rmdir($path);
	}

	public static function copy(string $source, string $destination): bool
	{
		self::required($source);

		$source = self::resolve($source);

		if (!is_dir($source)) {
			throw new discSystemException('Directory Not Found');
		}

		$destination = self::resolve($destination);

		$dir = \opendir($source);

		if (!is_dir($destination)) {
			mkdir($destination);
		}

		while (false !== ($file = \readdir($dir))) {
			if (($file != '.') && ($file != '..')) {
				if (\is_dir($source . '/' . $file)) {
					self::copy($source . '/' . $file, $destination . '/' . $file);
				} else {
					\copy($source . '/' . $file, $destination . '/' . $file);
				}
			}
		}

		\closedir($dir);

		return true;
	}

	/* New Methods */

	/**
	 * Method varPhp
	 *
	 * @param $input $input [explicite description]
	 *
	 * @return string
	 */
	public static function varPhp($input): string
	{
		$string = '';

		if (\is_array($input) || \is_object($input)) {
			$string = '<?php return ' . \str_replace(['Closure::__set_state', 'stdClass::__set_state'], '(object)', \var_export($input, true)) . ';';
		} elseif (\is_scalar($input)) {
			$string = '<?php return "' . \str_replace('"', '\"', $input) . '";';
		} else {
			throw new discSystemException('Unknown input type.');
		}

		return $string;
	}

	/**
	 * Method varJson
	 *
	 * @param $input $input [explicite description]
	 * @param bool $pretty [explicite description]
	 * @param ?int $flags [explicite description]
	 * @param ?int $depth [explicite description]
	 *
	 * @return string
	 */
	public static function varJson($input, bool $pretty = false, ?int $flags = null, ?int $depth = 512): string
	{
		$flags = ($flags) ?? self::JSONFLAGS;
		$depth = ($depth) ?? 512;

		if ($pretty) {
			$flags = $flags | JSON_PRETTY_PRINT;
		}

		return json_encode($input, $flags, $depth);
	}

	/**
	 * Method varIni
	 *
	 * @param array $array [explicite description]
	 * @param array $parent [explicite description]
	 *
	 * @return string
	 */
	public static function varIni(array $array, array $parent = []): string
	{
		$ini = '';

		foreach ($array as $key => $value) {
			if (\is_array($value)) {
				//subsection case
				//merge all the sections into one array...
				$subsection = \array_merge((array) $parent, (array) $key);
				//add section information to the output
				$ini .= '[' . \join('.', $subsection) . ']' . PHP_EOL;
				//recursively traverse deeper
				$ini .= self::varIni($value, $subsection);
			} else {
				//plain key->value case
				$ini .= "$key=$value" . PHP_EOL;
			}
		}

		return $ini;
	}


	/**
	 * Reads entire file into a string
	 *
	 * @param string $path
	 * @return string
	 */
	public static function loadContent(string $requiredPath): string
	{
		self::required($requiredPath);

		return \file_get_contents(self::resolve($requiredPath));
	}

	/**
	 * New
	 *
	 * var_import_file — import a var_export_file(...) file
	 *
	 * @param string $path
	 * @return mixed
	 * @throws Exception
	 */
	public static function loadPhp(string $requiredPath)
	{
		self::required($requiredPath);

		return include self::resolve($requiredPath);
	}

	/**
	 * Method getJson
	 *
	 * @param string $path [explicite description]
	 *
	 * @return void
	 */
	public static function loadJson(string $requiredPath)
	{
		self::required($requiredPath);

		$json = json_decode(self::loadContent($requiredPath), true);

		if (json_last_error() !== JSON_ERROR_NONE) {
			throw new discSystemException('JSON file "' . $requiredPath . '" is not valid JSON.');
		}

		return $json;
	}

	/**
	 * parse_ini_file — Parse a configuration file
	 *
	 * @param string $path
	 * @param bool $process_sections create a multidimensional array
	 * @param int $scanner_mode INI_SCANNER_NORMAL, INI_SCANNER_RAW, INI_SCANNER_TYPED
	 * @return mixed
	 */
	public static function loadIni(string $requiredPath, bool $processSections = false, int $scannerMode = INI_SCANNER_NORMAL) /* mixed */
	{
		self::required($requiredPath);

		$ini = false;

		$ini = \parse_ini_file(self::resolve($requiredPath), $processSections, $scannerMode);

		if (!$ini) {
			throw new discSystemException('INI file "' . $requiredPath . '" is not valid.');
		}

		return $ini;
	}

	/**
	 * Method get
	 *
	 * @param string $path [explicite description]
	 * @param $arg1 $arg1 [explicite description]
	 * @param $arg2 $arg2 [explicite description]
	 *
	 * @return void
	 */
	public static function load(string $path, $arg1 = null, $arg2 = null) /* mixed */
	{
		$output = null;

		switch (\pathinfo($path, PATHINFO_EXTENSION)) {
			case 'ini':
				$arg1 = ($arg1) ?? true;
				$arg2 = ($arg2) ?? INI_SCANNER_TYPED;

				$output = self::loadIni($path, $arg1, $arg2);
				break;
			case 'json':
				$output = self::loadJson($path);
				break;
			case 'php':
				$output = self::loadPhp($path);
				break;
			default:
				$output = self::loadContent($path);
		}

		return $output;
	}


	/**
	 * file_put_contents — Write data to a file
	 *
	 * This should have thrown an error before not being able to write a file_exists
	 * This writes the file in a atomic fashion unless you use $flags
	 *
	 * @param string $path
	 * @param mixed $content
	 * @param int $flags
	 * @return mixed returns the number of bytes that were written to the file, or FALSE on failure.
	 */
	public static function saveContent(string $path, $content, ?int $flags = 0, ?int $chmod = null): int
	{
		$bytes = 0;

		/* if they aren't using any special flags just make it atomic that way locks aren't needed or partially written files aren't read */
		if ($flags > 0) {
			self::autoGenMissingDirectory($path);

			$bytes = \file_put_contents(self::resolve($path), $content, $flags);
		} else {
			/* if no flags provided do it the atomic way */
			$bytes = self::atomicSaveContent($path, $content);
		}

		return self::changeModeOnBytes($path, $bytes, $chmod);
	}

	/**
	 * Method putPhp
	 *
	 * @param string $path [explicite description]
	 * @param $data $data [explicite description]
	 * @param ?int $chmod [explicite description]
	 *
	 * @return int
	 */
	public static function savePhp(string $path, $data, ?int $chmod = null): int
	{
		$bytes = self::changeModeOnBytes($path, self::atomicSaveContent($path, self::varPhp($data)), $chmod);

		/* if it's cached we need to flush it out so the old one isn't loaded */
		self::removePhpFileFromOpcache($path);

		return $bytes;
	}

	/**
	 * Method putJson
	 *
	 * @param string $path [explicite description]
	 * @param $jsonObj $jsonObj [explicite description]
	 * @param bool $pretty [explicite description]
	 * @param ?int $flags [explicite description]
	 * @param ?int $depth [explicite description]
	 * @param ?int $chmod [explicite description]
	 *
	 * @return int
	 */
	public static function saveJson(string $path, $jsonObj, bool $pretty = false, ?int $flags = null, ?int $depth = 512, ?int $chmod = null): int
	{
		return self::changeModeOnBytes($path, self::atomicSaveContent($path, self::varJson($jsonObj, $pretty, $flags, $depth)), $chmod);
	}

	/**
	 * Method putIni
	 *
	 * @param string $path [explicite description]
	 * @param array $array [explicite description]
	 * @param ?int $chmod [explicite description]
	 *
	 * @return int
	 */
	public static function saveIni(string $path, array $array, ?int $chmod = null): int
	{
		return self::changeModeOnBytes($path, self::atomicSaveContent($path, self::varIni($array)), $chmod);
	}

	/**
	 * Method put
	 *
	 * @param string $path [explicite description]
	 * @param $input $input [explicite description]
	 * @param int $chmod [explicite description]
	 * @param $arg1 $arg1 [explicite description]
	 *
	 * @return int
	 */
	public static function save(string $path, $input, int $chmod = null, $arg1 = null): int
	{
		switch (\pathinfo($path, PATHINFO_EXTENSION)) {
			case 'ini':
				$bytes = self::saveIni($path, (array)$input, $chmod);
				break;
			case 'json':
				$arg1 = ($arg1) ?? false;
				$bytes = self::saveJson($path, $input, $arg1, null, null, $chmod);
				break;
			case 'php':
				$bytes = self::savePhp($path, $input, $chmod);
				break;
			default:
				$bytes = self::saveContent($path, $input, (int)$arg1, $chmod);
		}

		return $bytes;
	}

	/**
	 * New (but used automatically by file_put_contents when no flags are used)
	 *
	 * atomicFilePutContents - atomic file_put_contents
	 *
	 * @param string $path
	 * @param mixed $content
	 * @return int returns the number of bytes that were written to the file.
	 */
	public static function atomicSaveContent(string $path, $content): int
	{
		/* create absolute path */
		$path = self::resolve($path);

		self::autoGenMissingDirectory($path);

		/* get the path where you want to save this file so we can put our file in the same directory */
		$directory = \dirname($path);

		/* is this directory writeable */
		if (!is_writable($directory)) {
			throw new discSystemException($directory . ' is not writable.');
		}

		/* create a temporary file with unique file name and prefix */
		$temporaryFile = \tempnam($directory, 'afpc_');

		/* did we get a temporary filename */
		if ($temporaryFile === false) {
			throw new discSystemException('Could not create temporary file ' . $temporaryFile . '.');
		}

		/* write to the temporary file */
		$bytes = \file_put_contents($temporaryFile, $content, LOCK_EX);

		/* did we write anything? */
		if ($bytes === false) {
			throw new discSystemException('No bytes written by file_put_contents');
		}

		/* move it into place - this is the atomic function */
		if (\rename($temporaryFile, $path) === false) {
			throw new discSystemException('Could not rename temporary file ' . $temporaryFile . ' ' . $path . '.');
		}

		/* return the number of bytes written */
		return $bytes;
	}

	/**
	 * Method removePhpFileFromOpcache
	 *
	 * @param string $path [path to file/directory]
	 *
	 * @return bool
	 */
	public static function removePhpFileFromOpcache(string $path): bool
	{
		return (\function_exists('opcache_invalidate')) ? \opcache_invalidate(self::resolve($path), true) : true;
	}

	/**
	 * Method bytesToString
	 *
	 * @param int $bytes [explicite description]
	 *
	 * @return string
	 */
	public static function formatSize(int $bytes): string
	{
		$i = floor(log($bytes, 1024));

		return round($bytes / pow(1024, $i), [0, 0, 2, 2, 3][$i]) . ['B', 'kB', 'MB', 'GB', 'TB'][$i];
	}

	/**
	 * Method permissionsFormatted
	 *
	 * @param int $mode [explicite description]
	 * @param int $option [explicite description]
	 *
	 * @return string
	 */
	public static function formatPermissions(int $mode, int $option = 3): string
	{
		$info = '';

		if (1 & $option) {
			switch ($mode & 0xF000) {
					// socket
				case 0xC000:
					$info = 's';
					break;
					// symbolic link
				case 0xA000:
					$info = 'l';
					break;
					// regular
				case 0x8000:
					$info = 'r';
					break;
					// block special
				case 0x6000:
					$info = 'b';
					break;
					// directory
				case 0x4000:
					$info = 'd';
					break;
					// character special
				case 0x2000:
					$info = 'c';
					break;
					// FIFO pipe
				case 0x1000:
					$info = 'p';
					break;
					// unknown
				default:
					$info = 'u';
			}
		}

		if (2 & $option) {
			// Owner
			$info .= (($mode & 0x0100) ? 'r' : '-');
			$info .= (($mode & 0x0080) ? 'w' : '-');
			$info .= (($mode & 0x0040) ? (($mode & 0x0800) ? 's' : 'x') : (($mode & 0x0800) ? 'S' : '-'));

			// Group
			$info .= (($mode & 0x0020) ? 'r' : '-');
			$info .= (($mode & 0x0010) ? 'w' : '-');
			$info .= (($mode & 0x0008) ? (($mode & 0x0400) ? 's' : 'x') : (($mode & 0x0400) ? 'S' : '-'));

			// World
			$info .= (($mode & 0x0004) ? 'r' : '-');
			$info .= (($mode & 0x0002) ? 'w' : '-');
			$info .= (($mode & 0x0001) ? (($mode & 0x0200) ? 't' : 'x') : (($mode & 0x0200) ? 'T' : '-'));
		}

		return $info;
	}

	/**
	 * PROTECTED
	 */

	/**
	 * Method listRecursive
	 *
	 * @param string $pattern [explicite description]
	 * @param int $flags [explicite description]
	 *
	 * @return array
	 */
	protected static function listRecursive(string $pattern, int $flags = 0): array
	{
		$files = \glob($pattern, $flags);

		foreach (\glob(\dirname($pattern) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR | GLOB_NOSORT) as $directory) {
			/* recursive loop */
			$files = \array_merge($files, self::listRecursive($directory . DIRECTORY_SEPARATOR . \basename($pattern), $flags));
		}

		return $files;
	}

	public static function changeModeOnBytes(string $path, int $bytes, ?int $chmod): int
	{
		if ($bytes && $chmod) {
			\chmod(self::resolve($path), $chmod);
		}

		return $bytes;
	}

	public static function autoGenMissingDirectory(string $requiredPath)
	{
		if (self::$autoGenerateDirectories) {
			self::makeDirectory(dirname($requiredPath));
		}
	}

	public static function rename(File $fileObj, string $newname): File
	{
		Disc::autoGenMissingDirectory($newname);

		$oldname = $fileObj->getRealPath();

		$fileObj = null; /* close */

		\rename($oldname, Disc::resolve($newname));

		return self::file($newname);
	}
} /* end class */
